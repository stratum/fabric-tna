// Copyright 2021-present Open Networking Foundation
// SPDX-License-Identifier: LicenseRef-ONF-Member-Only-1.0

#include <core.p4>
#include <tna.p4>

#include "../header.p4"

// Check Stratum's chassis_config for other queue IDs.
const qid_t BEST_EFFORT_QUEUE = 0;

// ACL-like classification, maps lookup metadata to slice_id and tc. For UE
// traffic, values can be overriden by the SPGW PDR tables.
control IngressSliceTcClassifier (inout fabric_ingress_metadata_t fabric_md) {

    DirectCounter<bit<32>>(CounterType_t.PACKETS) classifier_stats;

    action set_slice_id_tc(slice_id_t slice_id, tc_t tc) {
        fabric_md.slice_id = slice_id;
        fabric_md.tc = tc;
        classifier_stats.count();
    }

    table classifier {
        key = {
            fabric_md.lkp.ipv4_src : ternary @name("ipv4_src");
            fabric_md.lkp.ipv4_dst : ternary @name("ipv4_dst");
            fabric_md.lkp.ip_proto : ternary @name("ip_proto");
            fabric_md.lkp.l4_sport : ternary @name("l4_sport");
            fabric_md.lkp.l4_dport : ternary @name("l4_dport");
        }
        actions = {
            set_slice_id_tc;
        }
        const default_action = set_slice_id_tc(DEFAULT_SLICE_ID, DEFAULT_TC);
        counters = classifier_stats;
        size = QOS_CLASSIFIER_TABLE_SIZE;
    }

    apply {
        classifier.apply();
    }
}

// Provides metering and mapping to queues based on slice_id and tc.
control IngressQos (inout fabric_ingress_metadata_t fabric_md,
                    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
                    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md) {

    // One meter per tc per slice. The index should be slice_id++tc. Consider
    // using optional argument adjust_byte_count to account only for
    // user-generated bytes, i.e., exclude VLAN, MPLS, GTP-U.
    Meter<bit<SLICE_TC_WIDTH>>(1 << SLICE_TC_WIDTH, MeterType_t.BYTES) slice_tc_meter;

    DirectCounter<bit<32>>(CounterType_t.PACKETS) queues_stats;

    action set_queue(qid_t qid) {
        ig_tm_md.qid = qid;
        queues_stats.count();
    }

    // For policing.
    action meter_drop() {
        ig_dprsr_md.drop_ctl = 1;
        #ifdef WITH_INT
        fabric_md.bridged.int_bmd.drop_reason = IntDropReason_t.DROP_REASON_INGRESS_QOS_METER;
        #endif // WITH_INT
        queues_stats.count();
    }

    table queues {
        key = {
            fabric_md.slice_id:      exact   @name("slice_id");
            fabric_md.tc:            exact   @name("tc");
            ig_tm_md.packet_color:   ternary @name("color");
        }
        actions = {
            set_queue;
            meter_drop;
        }
        const default_action = set_queue(BEST_EFFORT_QUEUE);
        counters = queues_stats;
        size = 1 << (SLICE_TC_WIDTH + 1);
    }

    apply {
        // Meter index will be 0 for all packets with default slice_id and tc.
        ig_tm_md.packet_color = (bit<2>) slice_tc_meter.execute(fabric_md.slice_id++fabric_md.tc);
        queues.apply();
    }
}
